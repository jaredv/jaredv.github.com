// Generated by CoffeeScript 1.6.3
/*

TODO

--scientific notation input
--js latex output
--set variables
*/


(function() {
  var cl, parser,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  cl = function(x) {
    return console.log(x);
  };

  parser = function(input, debug) {
    var constants, constants2, log, ops, ops2, sops, sops2, x;
    if (debug == null) {
      debug = false;
    }
    log = function(x) {
      if (debug) {
        return cl(x);
      }
    };
    ops = {
      '(': {
        p: 0,
        f: function() {}
      },
      ')': {
        p: 0,
        f: function() {}
      },
      '+': {
        p: 1,
        f: function(a, b) {
          return a + b;
        }
      },
      '-': {
        p: 1,
        f: function(a, b) {
          return a - b;
        }
      },
      '*': {
        p: 2,
        f: function(a, b) {
          return a * b;
        }
      },
      '/': {
        p: 2,
        f: function(a, b) {
          return a / b;
        }
      },
      '^': {
        p: 3,
        f: function(a, b) {
          return Math.pow(a, b);
        }
      }
    };
    sops = {
      'sin': {
        p: 0,
        f: function(a) {
          return Math.sin(a);
        }
      },
      'cos': {
        p: 0,
        f: function(a) {
          return Math.cos(a);
        }
      },
      'tan': {
        p: 0,
        f: function(a) {
          return Math.tan(a);
        }
      },
      'ln': {
        p: 0,
        f: function(a) {
          return Math.log(a);
        }
      },
      'log': {
        p: 0,
        f: function(a) {
          return Math.log10(a);
        }
      },
      'sqrt': {
        p: 0,
        f: function(a) {
          return Math.sqrt(a);
        }
      }
    };
    constants = {
      'pi': function() {
        return Math.PI;
      },
      'e': function() {
        return Math.E;
      },
      'random': function() {
        return Math.random();
      }
    };
    ops2 = Object.keys(ops);
    sops2 = Object.keys(sops);
    constants2 = Object.keys(constants);
    this.cmd = function(input) {};
    this.toChunks = function(text) {
      var char, chunks, x, _i, _len;
      chunks = [];
      for (_i = 0, _len = text.length; _i < _len; _i++) {
        char = text[_i];
        if (!isNaN(char) || char === '.') {
          x = chunks[chunks.length - 1];
          if (!isNaN(x) || x === '.') {
            chunks[chunks.length - 1] += char;
          } else {
            chunks.push(char);
          }
        } else if (__indexOf.call(ops2, char) >= 0) {
          chunks.push(char);
        } else {
          x = chunks[chunks.length - 1];
          if (x && isNaN(x) && __indexOf.call(ops2, x) < 0) {
            chunks[chunks.length - 1] += char;
          } else {
            chunks.push(char);
          }
        }
      }
      log(chunks);
      return chunks;
    };
    this.toPostfix = function(infix) {
      var c, next, postfix, stack, _i, _len;
      stack = [];
      postfix = [];
      this.precedence = function(x) {
        if (__indexOf.call(ops2, x) >= 0) {
          return ops[x]['p'];
        } else {
          return 99;
        }
      };
      for (_i = 0, _len = infix.length; _i < _len; _i++) {
        c = infix[_i];
        if (c === '(') {
          stack.push(c);
        } else if (c === ')') {
          next = stack.pop();
          while (next !== '(') {
            postfix.push(next);
            next = stack.pop();
          }
        } else if (!isNaN(c) || __indexOf.call(constants2, c) >= 0) {
          postfix.push(c);
        } else if (__indexOf.call(ops2, c) >= 0 || __indexOf.call(sops2, c) >= 0) {
          while (stack.length !== 0 && this.precedence(c) <= this.precedence(stack[stack.length - 1])) {
            postfix.push(stack.pop());
          }
          stack.push(c);
        }
      }
      while (stack.length > 0) {
        postfix.push(stack.pop());
      }
      log(postfix);
      return postfix;
    };
    this.evalPostfix = function(pf) {
      var a, b, c, r, stack, _i, _len;
      stack = [];
      for (_i = 0, _len = pf.length; _i < _len; _i++) {
        c = pf[_i];
        if (__indexOf.call(constants2, c) >= 0) {
          stack.push(constants[c]());
        } else if (__indexOf.call(sops2, c) >= 0) {
          cl(stack);
          a = parseFloat(stack.pop());
          r = sops[c].f(a);
          stack.push(r);
        } else if (__indexOf.call(ops2, c) >= 0) {
          b = parseFloat(stack.pop());
          a = parseFloat(stack.pop());
          r = ops[c].f(a, b);
          stack.push(r);
        } else {
          stack.push(c);
        }
      }
      return stack[0];
    };
    x = this.toChunks(input);
    x = this.toPostfix(x);
    x = this.evalPostfix(x);
    return x;
  };

  cl(parser('sqrt(4)', true));

}).call(this);
